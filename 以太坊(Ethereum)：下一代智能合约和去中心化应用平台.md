# 以太坊(Ethereum)：下一代智能合约和去中心化应用平台

---
以太坊的目标就是提供一个带有内置的成熟的图灵完备语言的区块链，用这种语言可以创建合约来编码任意状态转换功能，用户只要简单地用几行代码来实现逻辑，就能够创建以上提及的所有系统以及许多我们还想象不到的其他系统。


### 历史
从技术角度讲，比特币账本可以被认为是一个状态转换系统，该系统包括所有现存的比特币所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。
<div align = "center">
<img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"/>
    </div>
例如，在标准的银行系统中，状态就是资产负债表，一个从A账户向B账户转账X美元的请求是一笔交易，状态转换函数从A账户中减去X美元，向B账户中增加X元。如果A账户的余额小于X美元，状态转换函数就会返回错误提示。

比特币系统中，状态转换函数APPLY(S,TX)->S' 大体上可以如下定义：
1. 交易的每个输入：

    * 如果引用的UTXO(没有花费的比特币) 不存在于现在的状态中(S)，返回错误提示
    * 如果签名与UTXO所有者的签名不一致，返回错误提示
2. 如果所有的UTXO输入面值总额小于所有的UTXO输出面值总额，返回错误提示
3. 返回新状态S'，新状态S'中移除了所有的输入UTXO，增加了所有的输出UTXO

<div align = "center">
<img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E6%8C%96%E7%9F%BF.png"/>
    </div>

比特币的去中心化共识进程要求网络中的节点不断尝试将交易打包成“区块”。网络被设计为大约每十分钟产生一个区块，每个区块包含一个时间戳，一个随机数，一个对上一个区块的引用(即哈希)和上一区块生成以来发生的所有交易列表。这样随着时间流逝就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。

依照这个范式，检查一个区块是否有效的算法如下：
1. 检查区块引用的上一个区块是否存在且有效
2. 检查区块的时间戳是否晚于以前的区块的时间戳，而且早于未来2小时
3. 检查区块的工作量证明是否有效
4. 将上一个区块的最终状态赋于S[0]
5. 假设TX是区块的交易列表，包含n笔交易。对于属于0...n-1的所有进程i，进行状态转换S[i+1]=APPLY(S[i],TX[i])。如果任何一笔交易i在状态转换中出错，退出程序，返回错误。
6. 返回正确，状态S[n]是这一区块的最终状态。

本质上，区块中的每笔交易必须提供一个正确的状态转换，要注意的是，“状态”并不是编码到区块的。它纯粹只是被校验节点记住的抽象概念，对于任意区块都可以从创世状态开始，按顺序加上每一个区块的每一笔交易，(妥妥的)计算出当前的状态。另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有A、B两笔交易，B花费的是A创建的UTXO，如果A在B以前，这个区块是有效的，否则，这个区块是无效的。

<div align = "center">
<img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91.png"/>
    </div>

左：仅提供默克尔树(Merkle Tree)上的少量节点已经足够给出的分支的合法证明
右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上的某处的不一致


比特币系统的一个重要可扩展特性是：它的区块存储在多层次的数据结构中。一个区块的哈希实际上只是区块头的哈希，区块头是包含时间戳、随机数、上个区块哈希和存储了所有区块交易的默克尔树的根哈希的长度的大约为200字节的一段数据。

## 以太坊
以太坊的目的是基于脚本、竞争币和链上元协议(on-chain meta-protocol)概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链，使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其他协议只需不到二十行代码就可以实现。智能合约包含价值而且只有满足某些条件才能够打开加密箱子。

### 以太坊账户
在以太坊系统中，状态是由被称为“账户”(每个账户由一个20字节的地址)的对象和在两个账户之间转移价值和信息的状态转换构成的。
以太坊账户包含四个部分：

* 随机数，用于确定每笔交易只能被处理一次的计数器
* 账户目前的以太币余额
* 账户的合约代码，如果有的话
* 账户的存储(默认为空)

以太坊(Ether)是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户(由私钥控制的)和合约账户(由合约代码控制)。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其他消息或者创建合约。

### 消息和交易
以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同。第一，以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。第二，以太坊消息可以选择包含数据。第三，如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。

以太坊中“交易”是指存储在外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和两个被称为STARTGAS和GASPRICE的数值。为了防止代码的指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤(包括初始消息和所有执行中引发的消息)做出限制。STARTGAS就是限制，GASPRICE是每一计算步骤需要支付矿工的费用。如果执行交易的过程中，“用完了燃料”，所有状态改变恢复原状态，但是已经支付的交易费用不可收回了。如果执行交易终止时还有剩余燃料，那么这些燃料将退还给发送者。创建合约有单独的交易类型和相应的消息类型，合约地址是基于账号随机数和交易数据的哈希计算出来的。

消息的一个重要后果是以太坊的“头等公民”财产，合约和外部账户拥有同样的权利，包括发送消息和创建其他合约的权利。这使得合约可以同时充当多个不同的角色，例如，用户可以使区中心化组织(一个合约)的一个成员成为一个中介账户(另一个合约)，为一个偏执的使用定制的基于量子证明的兰波特签名(第三个合约)的个人和一个自身使用由五个私钥保证安全的账户(第四个合约)的共同签名实体提供居间服务。以太坊平台的强大之处在于去中心化的组织和代理合约不需要关心合约的每一参与方是什么类型的账户。

### 以太坊转换函数

<div align = "center">
<img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0.png"/>
    </div>

以太坊的状态转换函数：`APPLY(S,TX) -> S'`，可以定义如下：
1. 检查交易的格式是否正确(即有正确数值)、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误
2. 计算交易费用：fee=STARTGAS * GASPRICE，并从签名中确定发送者的地址。从发送这的账户减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误
3. 设定初值：GAS = STARTGAS，并根据交易中的字节数减去一定量的燃料值
4. 从发送者的账户转移价值到接收者的账户。如果接收账户不存在，则创建此账户。如果接收账户是一个合约，运行合约的代码，知道代码运行结束或者燃料用完
5. 如果因为发送者没有足够的钱或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是需要支付交易费用，交易费用加至矿工账户。
6. 否则，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工

### 代码执行
以太坊合约的代码使用低级的基于堆栈的字节码的语言写成的，被称为"以太坊虚拟机代码"或"EVM代码"。代码由一系列字节构成，每一个字节代表一种操作。一般而言，代码执行是无限循环，程序计数器每增加一(初值为零)就执行一次操作，知道代码执行完毕或者遇到错误，STOP或者RETURN指令。操作可以访问三种存储数据的空间：

* 堆栈，一种后进先出的数据存储，32字节的数值可以入栈，出栈
* 内存，可无限扩展的字节队列
* 合约的长期存储，一个私钥/数值的存储，其中私钥和数值都是32字节大小，与计算结束即重置的堆栈和内存不同，存储内容将长期保持

代码可以像访问区块头数据一样访问数值，发送者和接受到的消息中的数据，代码还可以返回数据的字节队列作为输出。

EVM代码的正式执行模型令人惊讶地简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组(block_state, transaction, message, code, memory, stack, pc, gas)来定义，这里block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc(程序计数器)个字节，当前指令被找到，每个指令都有定义自己如何影响元组。例如，ADD将两个元素出栈并将它们的和入栈，将gas(燃料)减一并将pc加一，SSTORE将顶部的两个元素出栈并将第二个元素插入到由第一个元素定义的合约存储位置，同样减少最多200的gas并将pc加一，虽然有许多方法通过即时编译去优化以太坊，但以太坊的基础性的实施可以用几百行代码实现。

### 区块链和挖矿

<div align = "center">
<img src="https://raw.githubusercontent.com/lengender/MarkdownPhotos/master/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0.png"/>
    </div>
    
以太坊和比特币区块链架构的不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。以太坊中的区块确认算法如下：
1. 检查区块引用的上一个区块是否存在和有效
2. 检查区块的时间戳是否比引用的上一个区块大，而且小于15分钟
3. 检查区块序号、难度值、交易根、叔根和燃料限额(许多以太坊特有的底层概念)是否有效
4. 检查区块的工作量证明是否有效
5. 将S[0]赋值为上一个区块的STATE_ROOT
6. 将TX赋值为区块的交易列表，一共有n笔交易，对于属于0...n-1的i，进行状态转换S[i+1] = APPLY(S[i], TX[i])。如果任何一个转换发生错误，或者程序执行到此处所花费的燃料(gas)超过了GASLIMIT，返回错误
7. 用S[n]给S_FINAL赋值，向矿工支付区块奖励
8. 检查S_FINAL是否与SATATE_ROOT相同，如果相同，区块是有效的。否则，区块是无效的











































